<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>洗濯機・風呂メンテナンス</title>
<style>
body {
font-family: sans-serif;
margin: 0;
padding: 20px;
display: flex;
justify-content: center;
background-color: #eeeeee;
overflow-y: auto;
}

.container {
width: 100%;
max-width: 600px;
}

h1 {
text-align: center;
font-size: 1.8em;
margin-bottom: 24px;
}

.task-card {
background-color: #fff;
border: 1px solid #ccc;
border-radius: 5px;
padding: 20px;
margin: 16px 0;
box-shadow: 2px 2px 0px rgba(0,0,0,0.1);
display: flex;
flex-direction: column;
align-items: center;
}

.task-title {
font-weight: bold;
font-size: 1.5em;
margin-bottom: 10px;
text-align: center;
letter-spacing: 0.05em;
}

.button-group {
display: flex;
flex-direction: row;
flex-wrap: wrap;
justify-content: center;
align-items: center;
gap: 12px;
margin-bottom: 6px;
}

button {
padding: 10px 24px;
border-radius: 3px;
border: none;
background: #5abebb;
color: white;
font-size: 1.1em;
cursor: pointer;
transition: background 0.2s;
}

button:hover {
background: #48aba8;
}

.next-date {
margin-top: 5px;
color: #555;
font-size: 1.1em;
text-align: center;
}

/* モーダル背景 */
.modal-overlay {
position: fixed;
top:0; left:0;
width:100%; height:100%;
background-color: rgba(0,0,0,0.5);
z-index: 9998;
}

.history-modal {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background-color: white;
border-radius: 3px;
padding: 20px;
box-shadow: 2px 2px 2px rgba(0,0,0,0.2);
z-index: 9999;
white-space: pre-line;
max-width: 90%;
max-height: 80%;
overflow-y: auto;
}
  
    .history-modal button {
    display: block;           /* 横幅いっぱいじゃなく、ブロックに */
    margin: 10px auto 0;      /* 上10px、左右自動、下0 */
    padding: 8px 16px;
    font-size: 1em;
    border-radius: 3px;
    border: none;
    background-color: #5abebb;
    color: white;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  .history-modal button:hover {
    background-color: #48aba8;
  }

@media (max-width: 400px) {
.task-title { font-size: 1.3em; }
button { padding: 12px 20px; font-size: 1em; }
.next-date { font-size: 1em; }
}
</style>
</head>
<body>
<div class="container">
<h1>洗濯機・風呂メンテナンス</h1>
<div id="maintenance-list"></div>
</div>

<script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

// --- Supabase URL と ANON KEY を設定 ---
const SUPABASE_URL = 'https://cyyavrlclxparfkcwmkg.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN5eWF2cmxjbHhwYXJma2N3bWtnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYyMDg2MDQsImV4cCI6MjA3MTc4NDYwNH0.oUCzHzhUWYPju65rtGJEdgXHIHkac42tREPCXGGx3rU';
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

function formatDateJP(dateString) {
const date = new Date(dateString);
const year = date.getFullYear();
const month = date.getMonth() + 1;
const day = date.getDate();
return `${year}年${month}月${day}日`;
}

function calculateNextDate(latestDone, task_type) {
let date = latestDone ? new Date(latestDone) : new Date();

if (task_type.includes('2ヶ月')) date.setMonth(date.getMonth() + 2);
else if (task_type.includes('3ヶ月')) date.setMonth(date.getMonth() + 3);
else if (task_type.includes('2週間')) date.setDate(date.getDate() + 14);
else date.setMonth(date.getMonth() + 1);

const year = date.getFullYear();
const month = date.getMonth() + 1;
const day = date.getDate();
return `${year}年${month}月${day}日`;
}

async function fetchTasks() {
const { data: tasks, error: tasksError } = await supabase
.from('maintenance_tasks')
.select('*')
.order('id', { ascending: true });

if (tasksError) { console.error(tasksError); return; }

const container = document.getElementById('maintenance-list');
container.innerHTML = '';

for (const task of tasks) {
const { data: historyData } = await supabase
.from('maintenance_history')
.select('done_at')
.eq('task_id', task.id)
.order('done_at', { ascending: false })
.limit(1);

const latestDone = historyData && historyData.length > 0 ? historyData[0].done_at : null;

const card = document.createElement('div');
card.className = 'task-card';

const title = document.createElement('div');
title.className = 'task-title';
title.textContent = task.task_name;

const buttons = document.createElement('div');
buttons.className = 'button-group';

const useBtn = document.createElement('button');
useBtn.textContent = '実施した';
useBtn.onclick = async () => {
const { error: insertError } = await supabase
.from('maintenance_history')
.insert({ task_id: task.id, done_at: new Date() });
if (insertError) { console.error(insertError); return; }
nextDateDiv.textContent = '次回: ' + calculateNextDate(new Date().toISOString(), task.task_type);
};

const historyBtn = document.createElement('button');
historyBtn.textContent = '履歴';
historyBtn.onclick = async () => {
const { data: hist, error: histError } = await supabase
.from('maintenance_history')
.select('*')
.eq('task_id', task.id)
.order('done_at', { ascending: false })
.limit(10);
if (histError) { console.error(histError); return; }

const formatted = hist.map(h => formatDateJP(h.done_at)).join('\n') || '履歴なし';

// モーダル背景
const overlay = document.createElement('div');
overlay.className = 'modal-overlay';
overlay.onclick = () => { document.body.removeChild(overlay); document.body.removeChild(modal); };

// モーダル本体
const modal = document.createElement('div');
modal.className = 'history-modal';
modal.textContent = formatted;

const closeBtn = document.createElement('button');
closeBtn.textContent = '閉じる';
closeBtn.style.marginTop = '10px';
closeBtn.onclick = () => { document.body.removeChild(overlay); document.body.removeChild(modal); };

modal.appendChild(document.createElement('br'));
modal.appendChild(closeBtn);

document.body.appendChild(overlay);
document.body.appendChild(modal);
};

buttons.appendChild(useBtn);
buttons.appendChild(historyBtn);

const nextDateDiv = document.createElement('div');
nextDateDiv.className = 'next-date';
nextDateDiv.textContent = '次回: ' + calculateNextDate(latestDone, task.task_type);

card.appendChild(title);
card.appendChild(buttons);
card.appendChild(nextDateDiv);

container.appendChild(card);
}
}

fetchTasks();
</script>
</body>
</html>


